/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ResponseCreated,
  ResponseCreated$inboundSchema,
} from "./responsecreated.js";
import { ResponseDone, ResponseDone$inboundSchema } from "./responsedone.js";
import {
  ResponseOutputContentFull,
  ResponseOutputContentFull$inboundSchema,
} from "./responseoutputcontentfull.js";
import {
  ResponseOutputItemAdded,
  ResponseOutputItemAdded$inboundSchema,
} from "./responseoutputitemadded.js";
import {
  ResponseOutputItemDone,
  ResponseOutputItemDone$inboundSchema,
} from "./responseoutputitemdone.js";
import {
  ResponseOutputTextDelta,
  ResponseOutputTextDelta$inboundSchema,
} from "./responseoutputtextdelta.js";
import {
  ResponseStarting,
  ResponseStarting$inboundSchema,
} from "./responsestarting.js";

export type Data =
  | (ResponseOutputItemAdded & { type: "response.output_item.added" })
  | (ResponseOutputContentFull & { type: "response.output_content.full" })
  | (ResponseOutputItemDone & { type: "response.output_item.done" })
  | (ResponseOutputTextDelta & { type: "response.output_text.delta" })
  | (ResponseDone & { type: "response.done" })
  | (ResponseCreated & { type: "response.created" })
  | (ResponseStarting & { type: "response.starting" });

/**
 * A server-sent event containing stock market update content
 */
export type AgentRunsStreamingResponse = {
  /**
   * Sequence number of the SSE event, starts from 0
   */
  id: string;
  /**
   * The type of the SSE event
   */
  event: string;
  data:
    | (ResponseOutputItemAdded & { type: "response.output_item.added" })
    | (ResponseOutputContentFull & { type: "response.output_content.full" })
    | (ResponseOutputItemDone & { type: "response.output_item.done" })
    | (ResponseOutputTextDelta & { type: "response.output_text.delta" })
    | (ResponseDone & { type: "response.done" })
    | (ResponseCreated & { type: "response.created" })
    | (ResponseStarting & { type: "response.starting" });
};

/** @internal */
export const Data$inboundSchema: z.ZodMiniType<Data, unknown> = z.union([
  z.intersection(
    ResponseOutputItemAdded$inboundSchema,
    z.object({ type: z.literal("response.output_item.added") }),
  ),
  z.intersection(
    ResponseOutputContentFull$inboundSchema,
    z.object({ type: z.literal("response.output_content.full") }),
  ),
  z.intersection(
    ResponseOutputItemDone$inboundSchema,
    z.object({ type: z.literal("response.output_item.done") }),
  ),
  z.intersection(
    ResponseOutputTextDelta$inboundSchema,
    z.object({ type: z.literal("response.output_text.delta") }),
  ),
  z.intersection(
    ResponseDone$inboundSchema,
    z.object({ type: z.literal("response.done") }),
  ),
  z.intersection(
    ResponseCreated$inboundSchema,
    z.object({ type: z.literal("response.created") }),
  ),
  z.intersection(
    ResponseStarting$inboundSchema,
    z.object({ type: z.literal("response.starting") }),
  ),
]);

export function dataFromJSON(
  jsonString: string,
): SafeParseResult<Data, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data' from JSON`,
  );
}

/** @internal */
export const AgentRunsStreamingResponse$inboundSchema: z.ZodMiniType<
  AgentRunsStreamingResponse,
  unknown
> = z.object({
  id: types.string(),
  event: types.string(),
  data: z.pipe(
    z.pipe(
      z.string(),
      z.transform((v, ctx) => {
        try {
          return JSON.parse(v);
        } catch (err) {
          ctx.issues.push({
            input: v,
            code: "custom",
            message: `malformed json: ${err}`,
          });
          return z.NEVER;
        }
      }),
    ),
    z.union([
      z.intersection(
        ResponseOutputItemAdded$inboundSchema,
        z.object({ type: z.literal("response.output_item.added") }),
      ),
      z.intersection(
        ResponseOutputContentFull$inboundSchema,
        z.object({ type: z.literal("response.output_content.full") }),
      ),
      z.intersection(
        ResponseOutputItemDone$inboundSchema,
        z.object({ type: z.literal("response.output_item.done") }),
      ),
      z.intersection(
        ResponseOutputTextDelta$inboundSchema,
        z.object({ type: z.literal("response.output_text.delta") }),
      ),
      z.intersection(
        ResponseDone$inboundSchema,
        z.object({ type: z.literal("response.done") }),
      ),
      z.intersection(
        ResponseCreated$inboundSchema,
        z.object({ type: z.literal("response.created") }),
      ),
      z.intersection(
        ResponseStarting$inboundSchema,
        z.object({ type: z.literal("response.starting") }),
      ),
    ]),
  ),
});

export function agentRunsStreamingResponseFromJSON(
  jsonString: string,
): SafeParseResult<AgentRunsStreamingResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentRunsStreamingResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentRunsStreamingResponse' from JSON`,
  );
}
