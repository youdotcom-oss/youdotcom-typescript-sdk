/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smartUnion.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export const SearchServerList = [
  "https://ydc-index.io",
] as const;

/**
 * Specifies the freshness of the results to return.
 */
export type Freshness = models.Freshness | string;

/**
 * The country code that determines the geographical focus of the web results.
 */
export type Country = models.Country | string;

/**
 * Configures the safesearch filter for content moderation. This allows you to decide whether to return NSFW content or not.
 */
export type Safesearch = models.SafeSearch | string;

/**
 * Indicates which section(s) of search results to livecrawl and return full page content.
 */
export type Livecrawl = models.LiveCrawl | string;

/**
 * Indicates the format of the livecrawled content.
 */
export type LivecrawlFormats = models.LiveCrawlFormats | string;

export type SearchRequest = {
  /**
   * The search query used to retrieve relevant results from the web. You can also include [search operators](#search-operators) to refine your search.
   */
  query?: string | undefined;
  /**
   * Specifies the maximum number of search results to return per section (the sections are `web` and `news`. See the JSON response to visualize them).
   */
  count?: number | undefined;
  /**
   * Specifies the freshness of the results to return.
   */
  freshness?: models.Freshness | string | undefined;
  /**
   * Indicates the `offset` for pagination. The `offset` is calculated in multiples of `count`. For example, if `count = 5` and `offset = 1`, results 5–10 will be returned. Range `0 ≤ offset ≤ 9`.
   */
  offset?: number | undefined;
  /**
   * The country code that determines the geographical focus of the web results.
   */
  country?: models.Country | string | undefined;
  /**
   * Configures the safesearch filter for content moderation. This allows you to decide whether to return NSFW content or not.
   */
  safesearch?: models.SafeSearch | string | undefined;
  /**
   * Indicates which section(s) of search results to livecrawl and return full page content.
   */
  livecrawl?: models.LiveCrawl | string | undefined;
  /**
   * Indicates the format of the livecrawled content.
   */
  livecrawlFormats?: models.LiveCrawlFormats | string | undefined;
};

export type Web = {
  /**
   * The URL of the specific search result.
   */
  url?: string | undefined;
  /**
   * The title or name of the search result.
   */
  title?: string | undefined;
  /**
   * A brief description of the content of the search result.
   */
  description?: string | undefined;
  /**
   * An array of text snippets from the search result, providing a preview of the content.
   */
  snippets?: Array<string> | undefined;
  /**
   * URL of the thumbnail.
   */
  thumbnailUrl?: string | undefined;
  /**
   * The age of the search result.
   */
  pageAge?: Date | undefined;
  /**
   * An array of authors of the search result.
   */
  authors?: Array<string> | undefined;
  /**
   * The URL of the favicon of the search result's domain.
   */
  faviconUrl?: string | undefined;
};

export type News = {
  /**
   * The title of the news result.
   */
  title?: string | undefined;
  /**
   * A brief description of the content of the news result.
   */
  description?: string | undefined;
  /**
   * UTC timestamp of the article's publication date.
   */
  pageAge?: Date | undefined;
  /**
   * URL of the thumbnail.
   */
  thumbnailUrl?: string | undefined;
  /**
   * The URL of the news result.
   */
  url?: string | undefined;
};

export type Results = {
  web?: Array<Web> | undefined;
  news?: Array<News> | undefined;
};

export type Metadata = {
  requestUuid?: string | undefined;
  /**
   * Returns the search query used to retrieve the results.
   */
  query?: string | undefined;
  latency?: number | undefined;
};

/**
 * A JSON object containing unified search results from web and news sources
 */
export type SearchResponse = {
  results?: Results | undefined;
  metadata?: Metadata | undefined;
};

/** @internal */
export type Freshness$Outbound = string | string;

/** @internal */
export const Freshness$outboundSchema: z.ZodMiniType<
  Freshness$Outbound,
  Freshness
> = smartUnion([models.Freshness$outboundSchema, z.string()]);

export function freshnessToJSON(freshness: Freshness): string {
  return JSON.stringify(Freshness$outboundSchema.parse(freshness));
}

/** @internal */
export type Country$Outbound = string | string;

/** @internal */
export const Country$outboundSchema: z.ZodMiniType<Country$Outbound, Country> =
  smartUnion([models.Country$outboundSchema, z.string()]);

export function countryToJSON(country: Country): string {
  return JSON.stringify(Country$outboundSchema.parse(country));
}

/** @internal */
export type Safesearch$Outbound = string | string;

/** @internal */
export const Safesearch$outboundSchema: z.ZodMiniType<
  Safesearch$Outbound,
  Safesearch
> = smartUnion([models.SafeSearch$outboundSchema, z.string()]);

export function safesearchToJSON(safesearch: Safesearch): string {
  return JSON.stringify(Safesearch$outboundSchema.parse(safesearch));
}

/** @internal */
export type Livecrawl$Outbound = string | string;

/** @internal */
export const Livecrawl$outboundSchema: z.ZodMiniType<
  Livecrawl$Outbound,
  Livecrawl
> = smartUnion([models.LiveCrawl$outboundSchema, z.string()]);

export function livecrawlToJSON(livecrawl: Livecrawl): string {
  return JSON.stringify(Livecrawl$outboundSchema.parse(livecrawl));
}

/** @internal */
export type LivecrawlFormats$Outbound = string | string;

/** @internal */
export const LivecrawlFormats$outboundSchema: z.ZodMiniType<
  LivecrawlFormats$Outbound,
  LivecrawlFormats
> = smartUnion([models.LiveCrawlFormats$outboundSchema, z.string()]);

export function livecrawlFormatsToJSON(
  livecrawlFormats: LivecrawlFormats,
): string {
  return JSON.stringify(
    LivecrawlFormats$outboundSchema.parse(livecrawlFormats),
  );
}

/** @internal */
export type SearchRequest$Outbound = {
  query: string;
  count?: number | undefined;
  freshness?: string | string | undefined;
  offset?: number | undefined;
  country?: string | string | undefined;
  safesearch?: string | string | undefined;
  livecrawl?: string | string | undefined;
  livecrawl_formats?: string | string | undefined;
};

/** @internal */
export const SearchRequest$outboundSchema: z.ZodMiniType<
  SearchRequest$Outbound,
  SearchRequest
> = z.pipe(
  z.object({
    query: z._default(z.string(), "Your query"),
    count: z.optional(z.int()),
    freshness: z.optional(
      smartUnion([models.Freshness$outboundSchema, z.string()]),
    ),
    offset: z.optional(z.int()),
    country: z.optional(
      smartUnion([models.Country$outboundSchema, z.string()]),
    ),
    safesearch: z.optional(
      smartUnion([models.SafeSearch$outboundSchema, z.string()]),
    ),
    livecrawl: z.optional(
      smartUnion([models.LiveCrawl$outboundSchema, z.string()]),
    ),
    livecrawlFormats: z.optional(
      smartUnion([models.LiveCrawlFormats$outboundSchema, z.string()]),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      livecrawlFormats: "livecrawl_formats",
    });
  }),
);

export function searchRequestToJSON(searchRequest: SearchRequest): string {
  return JSON.stringify(SearchRequest$outboundSchema.parse(searchRequest));
}

/** @internal */
export const Web$inboundSchema: z.ZodMiniType<Web, unknown> = z.pipe(
  z.object({
    url: types.optional(types.string()),
    title: types.optional(types.string()),
    description: types.optional(types.string()),
    snippets: types.optional(z.array(types.string())),
    thumbnail_url: types.optional(types.string()),
    page_age: types.optional(types.date()),
    authors: types.optional(z.array(types.string())),
    favicon_url: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "thumbnail_url": "thumbnailUrl",
      "page_age": "pageAge",
      "favicon_url": "faviconUrl",
    });
  }),
);

export function webFromJSON(
  jsonString: string,
): SafeParseResult<Web, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Web$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Web' from JSON`,
  );
}

/** @internal */
export const News$inboundSchema: z.ZodMiniType<News, unknown> = z.pipe(
  z.object({
    title: types.optional(types.string()),
    description: types.optional(types.string()),
    page_age: types.optional(types.date()),
    thumbnail_url: types.optional(types.string()),
    url: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "page_age": "pageAge",
      "thumbnail_url": "thumbnailUrl",
    });
  }),
);

export function newsFromJSON(
  jsonString: string,
): SafeParseResult<News, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => News$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'News' from JSON`,
  );
}

/** @internal */
export const Results$inboundSchema: z.ZodMiniType<Results, unknown> = z.object({
  web: types.optional(z.array(z.lazy(() => Web$inboundSchema))),
  news: types.optional(z.array(z.lazy(() => News$inboundSchema))),
});

export function resultsFromJSON(
  jsonString: string,
): SafeParseResult<Results, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Results$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Results' from JSON`,
  );
}

/** @internal */
export const Metadata$inboundSchema: z.ZodMiniType<Metadata, unknown> = z.pipe(
  z.object({
    request_uuid: types.optional(types.string()),
    query: types.optional(types.string()),
    latency: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "request_uuid": "requestUuid",
    });
  }),
);

export function metadataFromJSON(
  jsonString: string,
): SafeParseResult<Metadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadata' from JSON`,
  );
}

/** @internal */
export const SearchResponse$inboundSchema: z.ZodMiniType<
  SearchResponse,
  unknown
> = z.object({
  results: types.optional(z.lazy(() => Results$inboundSchema)),
  metadata: types.optional(z.lazy(() => Metadata$inboundSchema)),
});

export function searchResponseFromJSON(
  jsonString: string,
): SafeParseResult<SearchResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchResponse' from JSON`,
  );
}
